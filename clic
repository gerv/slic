#!/usr/bin/python
# -*- coding: utf-8 -*-

import sys
import re
import json
import argparse
from os.path import dirname, exists, join, basename, split
from jinja2 import Environment, PackageLoader

import logging
logging.basicConfig(filename="clic.log", level=logging.DEBUG)
log = logging.getLogger("clic")

env = Environment(loader=PackageLoader('__main__', 'templates'),
                  trim_blocks=True,
                  extensions=['jinja2.ext.do'])

parser = argparse.ArgumentParser(description='Collate and process license information.')
parser.add_argument('--template', metavar="<template>",
                   help='Render the given template name')

args = parser.parse_args()

# A couple of functions used in the template
#
# Pop all keys from a dict which match a regexp or list of regexps, and return
# the dict of the popped items
def pop_by_re(regexps, dic):
    result = {}
    
    if type(regexps) == str:
        regexps = [regexps]

    for regexp in regexps:
        key_re = re.compile(regexp)
        for k in dic.keys():
          if key_re.search(k):
            result[k] = dic.pop(k)

    return result


def template_exists(template):
     path = join(dirname(sys.argv[0]), "templates", template)
     return exists(path)


# A mapping to reduce the number of times you get a given copyright holder
# listed "twice" because their name has multiple forms
canonical_holders = {
    'Silicon Graphics': 'Silicon Graphics Computer Systems, Inc.',
    'The Regents of the University of California. All rights reserved.':
               'Regents of the University of California. All rights reserved.',
    'Mozilla Foundation.': 'Mozilla Foundation'
}

def tidy_holder(holder):
    # Ick. Prevent "obvious" duplications of copyright holders
    if holder in canonical_holders:
        holder = canonical_holders[holder]
        
    return holder


# Take an array of integer years and turn it into a comma-separated string
# list of years and ranges
def _join_years(years):
    if not years:
        return ""
    
    # uniq
    set = {}
    map(set.__setitem__, years, [])
    years = set.keys()

    # sort
    years.sort()

    years_as_str = []
    range_start = None
    for i in range(len(years) - 1):
        if years[i + 1] == years[i] + 1:
            if not range_start:
                range_start = years[i]
        elif range_start:
            # No range continuation, pending value; finish range
            years_as_str.append("%i-%i" % (range_start, years[i]))
            range_start = None
        else:
            # No range continuation, no pending value
            years_as_str.append(str(years[i]))

    # Final year
    if range_start:
        # Pending value; finish range
        years_as_str.append("%i-%i" % (range_start, years[-1]))
    else:
        # No pending value
        years_as_str.append(str(years[-1]))

    return ", ".join(years_as_str) + " "
            

# Take a string list of years and ranges and turn it into an array of integer
# years
def _split_years(string):
    if not string:
        return []
    
    years = []
    for piece in string.split(','):
        if re.search("^\s*$", piece):
            # Blank line
            continue

        cw_piece = collapse_whitespace(piece)
        
        if re.search("-", piece):
            # Range
            rng = piece.split('-')
            if not rng[0] or not rng[1]:
                continue
            
            start = _canonicalize_year(rng[0])
            end = _canonicalize_year(rng[1])

            if start < 1970 or end > 2030:
                continue
                
            for i in range(start, end + 1):
                years.append(i)
        elif len(cw_piece) > 5:
            # Space-separated years? 5 rather than 4 to try and deal with
            # foolish typos such as "20010".
            sp_years = [_canonicalize_year(year) for year in piece.split()]
            years.extend(sp_years)
        elif len(cw_piece) == 4:
            # Single year
            years.append(_canonicalize_year(piece))
        else:
            log.warning("Year with strange length: '%s'" % cw_piece) 

    return years


# Make string year an integer, and expand from 2 digits to 4 if necessary
def _canonicalize_year(year):
    assert year != ''
    year = int(year)
    
    if year > 100 and year < 1970:
        log.warning("Strange year: '%s'" % year) 
    
    if year < 100:
        if year > 70:
            year = 1900 + year
        else:
            year = 2000 + year

    return year


# XXX Now in 3 places!
def collapse_whitespace(line):
    # Collapse whitespace
    line = re.sub("\s+", " ", line)

    # Strip leading and trailing whitespace
    line = re.sub("^\s", "", line)
    line = re.sub("\s$", "", line)
    
    return line


###############################################################################
# Load occurrence data file
occurrences = json.loads(open("occurrences.json").read())

# Rejig data structure so top-level key is the tag instead of the license
# text hash, and value is a list of the corresponding license objects
bytag = {}

for hash, occurrence in occurrences.items():
    tag = occurrence['tag']
    if tag in bytag:
        bytag[tag].append(occurrence)
    else:
        bytag[tag] = [occurrence]

# Post-process and amalgamate copyright lines
# \xa9 is the copyright symbol
copy_re = re.compile("""Copyright\s*
                        (\(C\)|\xa9)?\s*
                        (?P<years>[-\d,\s]*)
                        (?P<holder>.*)$""",
                     re.IGNORECASE | re.VERBOSE)

for tag in bytag:
    for data in bytag[tag]:
        if not 'copyrights' in data:
            continue
        
        # values() call to get past md5 hash keys
        copyrights = data['copyrights'].values()

        # Amalgamate years
        holders = {}
        for i in range(len(copyrights)):
            match = copy_re.search(copyrights[i])
            if match:
                hits = match.groupdict()
                log.info("Hits: %r" % hits)
                holder = tidy_holder(hits['holder'])
                years = _split_years(hits['years'])
                if holder in holders:
                    holders[holder].extend(years)
                else:
                    holders[holder] = years
            else:
                log.info("Copyright line doesn't match re: %s" % copyrights[i])

        # Rebuild copyright lines
        clean_copyrights = []
        for holder in holders:
            log.debug("Years: %r" % holders[holder])
            years = _join_years(holders[holder])
            copyright = u"Copyright \xa9 %s%s" % (years, holder)
            log.info("Clean C line: %s" % copyright)
            clean_copyrights.append(copyright)

        data['copyrights'] = clean_copyrights

# Reconcile Bison exception, which can be in a different comment to the GPL
# license and so is noted as a different "license" :-|
def resolve_bison_exception(bisonfile):
    log.debug("Trying to resolve bisonexception for file %s" % bisonfile)
    for tag in bytag:
        if not re.search("^GPL", tag):
            continue
        
        for data in bytag[tag]:
            gplfiles = data['files']
            for gplfile in gplfiles:
                if gplfile == bisonfile:
                    log.info("Resolved bisonexception for file %s" % bisonfile)
                    gplfiles.remove(gplfile)
                    return True

    log.warning("Unable to resolve bisonexception for file %s" % bisonfile)
    return False

if 'Bisonexception' in bytag:
    for data in bytag['Bisonexception']:
        bisonfiles = data['files']
        for bisonfile in bisonfiles:
            resolve_bison_exception(bisonfile)

# Sometimes a file header says "see file FOO for the license". If so, we tag
# it with a tag including 'fileref'. We must now go through all files so
# tagged and make sure that a corresponding license file has been found and
# included.

# Make a hash lookup table of all files found which match any of the special
# filenames
license_files_re = re.compile("^(LICENSE|COPYRIGHT|COPYING|MIT-LICENSE|NOTICE)")
license_files = {}
fileref_names = {
    'copyingfileref':    ['COPYING', 'NOTICE'],
    'copyrightfileref':  ['COPYRIGHT', 'NOTICE'],
    'bzip2fileref':      ['LICENSE', 'NOTICE'],
    'bsdfilerefxiph':    ['COPYING', 'NOTICE'],
    'bsdfileref':        ['LICENSE', 'NOTICE'],
    'mitfileref':        ['COPYING', 'NOTICE'],
    'mit_gpl20_fileref': ['MIT-LICENSE.txt', 'NOTICE'],
    'freetypefileref':   ['LICENSE.txt', 'NOTICE'],
    'ISCfileref':        ['LICENSE', 'NOTICE'],
}
    
for tag in bytag:
    for data in bytag[tag]:
        files = data['files']
        for file in files:
            filename = basename(file)
            if license_files_re.match(filename):
                license_files[file] = 1

# For each file marked as having a "fileref" license, see if an appropriate
# file in a higher directory is present and has been included somewhere
def find_license_file_for(file, license_file_names):
    log.debug("File path: %s" % file)
    for license_file_name in license_file_names:
        log.debug("Trying to find license file: %s" % license_file_name)
        dir = dirname(file)
        log.debug("Starting directory: %s" % dir)
        while dir != ".":
            if join(dir, license_file_name) in license_files:
                log.debug("Found license %s in dir: %s" % (license_file_name, dir))
                return True
            # Up one level
            dir = re.sub("/$", "", dir)
            dir = dirname(dir)
            log.debug("Moving up to dir: %s" % dir)
        
    log.debug("Found no license file for %s" % file)
    return False

fileref_problem_files = []
fileref_problem_dirs = {}

for tag in bytag:
    if not re.search("fileref", tag):
        continue

    if not tag in fileref_names:
        log.warning("No license file info for fileref tag '%s'" % tag)
        continue

    license_file_names = fileref_names[tag]
    
    for data in bytag[tag]:
        log.debug("Checking filerefs for tag %s" % tag)
        for file in data['files']:
            if not find_license_file_for(file, license_file_names):
                fileref_problem_files.append(file)
                fileref_problem_dirs[split(file)[0]] = 1

# Render output
if args.template:
    template = env.get_template(args.template)
    log.info("Rendering")
    print template.render({
        'licenses': bytag,
        'pop_by_re': pop_by_re,
        'template_exists': template_exists,
        'fileref_problem_files': fileref_problem_files,
        'fileref_problem_dirs': fileref_problem_dirs
    }).encode('utf-8')
