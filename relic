#!/usr/bin/python

# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.

# Note that this code has a long history of maintainers and being hacked on,
# including by people who don't know much Python. Please excuse the mess.

"""
    relic - Show the licenses of, or relicense, a given file, set of files,
            or directory of files

    Usage:
        relic [options...] [files...]
        relic [options...] < files...

    Options to Select Mode (use one):
        <none>              List the licenses in each file.
        -s, --statistics    Should a summary table of licenses in each file.
                            The -x, --extended option may be added to show
                            some additional detail to the stats.
        -r, --relicense     Modify the given files to use the MPL2.
        -A, --add           Add a license to files that do not appear to
                            have one.

    General Options:
        -h, --help          dump this help and exit
        -V, --version       dump this script's version and exit
        -v, --verbose       verbose output
        -d, --debug         more verbose output

        -f, --force         Continue processing after an error. (Errors
                            are summarized at end.)
        -q, --quick         Quick scanning. Use only basic license checks
                            (only use in report mode).
        -a, --all           Check all files (only skip CVS directories).
        --dry-run           Go through motions but don't actually change
                            any files.
        --backup            Make backups of changes files with
                            relicensing. Backup filenames are the
                            original filename suffixed with a ~# where
                            "#" is the lowest number to avoid a file
                            conflict.

    Examples:
        # List license in files under mozilla/js/src.
        relic mozilla/js/src        # list licenses in files
        relic -s mozilla/js/src     # show summary stats on licenses
        relic -r mozilla/js/src     # re-license files

"""

import os
import sys
import re
import getopt
import pprint
import shutil
import subprocess

class RelicError(Exception):
    pass

#---- setup logging
import logging
logging.basicConfig(filename="relic.log",level="INFO")
log = logging.getLogger("relic")

#---- globals
_version_ = (2, 0, 0)

# When processing files, 'relic' skips files and directories according
# to these settings. Note: files identified in .cvsignore files are also
# skipped.

treename = os.path.basename(os.getcwd()) 

def get_config(struct, treename):
    config = struct.get('_common')
    config.extend(struct.get(treename, []))
    return config

# List includes binary extensions in case binary checking is turned off
_g_skip_exts_config = {
  '_common' :
      [".mdp", ".order", ".dsp", ".dsw", ".json",
       ".png", ".jpg", ".jpeg", ".gif", ".tiff", ".rtf",
       ".pbxproj", ".pch", ".pem", ".icns", ".patch", ".diff",
       ".dic_delta", ".dic"],
}

_g_skip_exts = get_config(_g_skip_exts_config, treename)

# Files not to add a license to when they don't have one (due to
# inappropriateness or comment character confusion)
_g_skip_add_exts_config = {
  '_common': 
    [".txt", ".TXT", ".inc", ".s", ".manifest", ".map", ".dat"],
}

_g_skip_add_exts = get_config(_g_skip_add_exts_config, treename)

# Extensions to remove to reveal the "real" extension
_g_strip_exts_config = {
  '_common': [".in", ".dist"],
}

_g_strip_exts = get_config(_g_strip_exts_config, treename)

_g_skip_file_basenames_config = {
  '_common': [
    # Used by CVS (and this script)
    ".cvsignore",
    ".gitignore",
    ".gitattributes",
    ".hgignore",
    ".hgtags",
    ".bzrignore",
    
    # GPL with autoconf exception
    "config.guess",
    "config.sub",
    "aclocal.m4",

    # Auto-generated from other files
    "configure",

    # license and readme files
    "LICENSE",
    "license",
    "LICENSE-MPL",
    "LEGAL",
    "copyright",
    "README",
    "readme",
    "README.txt",
    "AUTHORS",
    "NEWS",
    "TODO",
    "ChangeLog",
    "ReadMe",
    "README.md",

    ".mozconfig",
    "ignore-me",

    "AndroidManifest.xml.in",
    
    # Catted into makefiles; can't have a header
    "android-resources.mn",
    
    # Don't know comment char; always short
    "module.ver",
  ],
}

_g_skip_file_basenames = get_config(_g_skip_file_basenames_config, treename)

_g_skip_dir_basenames_config = {
  '_common': [
    "CVS",
    ".hg",
    ".git",
    ".bzr",
  ],
}

_g_skip_dir_basenames = get_config(_g_skip_dir_basenames_config, treename)

_g_skip_add_dir_basenames_config = {
  '_common': [
    "mochitest",
    "reftest",
    "reftests",
    "crashtest",
    "crashtests",
    "test",
    "tests",
    "jsreftest",
    "imptests",
  ],
}

_g_skip_add_dir_basenames = get_config(_g_skip_add_dir_basenames_config, treename)

_g_skip_files_config = {
  '_common': [
  ],
  
  'mozilla-central': [
    # Files containing copies of licence text which confuses the script
    "gfx/cairo/cairo/COPYING-LGPL-2.1",
    "gfx/cairo/cairo/COPYING-MPL-1.1",
    
    # Files containing global licensing information
    "toolkit/content/license.html",
    
    # GPLed build tools
    "intl/uconv/tools/parse-mozilla-encoding-table.pl",
    "intl/uconv/tools/gen-big5hkscs-2001-mozilla.pl",
    
    # GPL with autoconf exception (same license as files distributed with)
    "build/autoconf/codeset.m4",
    "security/svrcore/depcomp",
    "security/svrcore/compile",
    "security/svrcore/missing",
    "security/svrcore/ltmain.sh",
    
    # Public domain or equivalent
    "nsprpub/config/nspr.m4",
    "security/nss/lib/freebl/mpi/mp_comba_amd64_sun.s",
    
    # GSSAPI has BSD-like licence requiring some attribution
    "extensions/auth/gssapi.h",

    # Catted into makefiles; can't have a header
    "mobile/android/sync/android-drawable-resources.mn",
    "mobile/android/sync/android-drawable-ldpi-resources.mn",
    "mobile/android/sync/preprocess-sources.mn",
    "mobile/android/sync/java-third-party-sources.mn",
    "mobile/android/sync/android-values-resources.mn",
    "mobile/android/sync/android-drawable-hdpi-resources.mn",
    "mobile/android/sync/java-sources.mn",
    "mobile/android/sync/android-layout-resources.mn",
    "mobile/android/sync/android-drawable-mdpi-resources.mn",
    
    # Catted in other ways
    "mobile/android/sync/manifests/SyncAndroidManifest_activities.xml.in",
    "mobile/android/sync/manifests/SyncAndroidManifest_permissions.xml.in",
    "mobile/android/sync/manifests/SyncAndroidManifest_services.xml.in",    
    
    # GPLed tools
    "toolkit/crashreporter/client/certdata2pem.py",
    "js/src/vm/make_unicode.py",
    
    # MPL 2, but too many license blocks too close to the top of file
    # and filename does not begin with "gen".
    "intl/chardet/tools/charfreqtostat.pl",
    
    # BSD
    "xpcom/glue/nsQuickSort.cpp",
    
    # Sample file
    "config/tests/src-simple/thesrcdir/preproc.in",
    
    # README
    "extensions/spellcheck/locales/en-US/hunspell/README_en_US.txt",
    "intl/locales/en-US/hyphenation/README_hyph_en_US.txt",
    
    # WHATWG
    "content/xml/content/src/htmlmathml-f.ent",
    
    "config/configobj.py", # BSD
    
    "dom/imptests/WebIDLParser.js", # MIT
    "dom/imptests/idlharness.js", # BSD
    "dom/imptests/testharness.js", # BSD
    
    "gfx/tests/gfxColorManagementTest.cpp", # "do anything"
    
    "intl/lwbrk/src/rulebrk.h", # liberal, MIT-like
    "intl/lwbrk/src/th_char.h", 
  ],

  'comm_central': [
  ],

  'addon_sdk': [
    # Addon SDK
    "doc/static-files/js/jquery.js", # MIT/GPL
    "examples/annotator/data/jquery-1.4.2.min.js", # MIT/GPL
    "examples/reddit-panel/data/jquery-1.4.4.min.js", # MIT/GPL
  ],

  'camino': [
    # Camino
    "src/extensions/ImageAndTextCell.m", # Apple BSD-like
    "src/extensions/ImageAndTextCell.h", # Apple BSD-like
    "src/extensions/MAAttachedWindow.m", # Matt Gemmill's copy of the above lic
    "src/extensions/MAAttachedWindow.h", # Matt Gemmill's copy of the above lic
    "IBPalette/resources/palette.table",
    "src/spotlight-importer/Importer-main.c",
  ],

  'browserid': [
    # BrowserID
    "resources/static/test/qunit.css", # MIT
  ],
  
  'instantbird': [
    # Must start with a newline; are appended to other files
    "instantbird/installer/windows/nsis/updater_append.ini",
    "instantbird/locales/updater_append.ini",
    
    # JSON data with wrong extension
    "instantbird/themes/smileys/theme.js",
  ],
}

_g_skip_files = get_config(_g_skip_files_config, treename)

# Complete path from mozilla dir to a dir to skip.
_g_skip_dirs_config = {
  '_common': [
  ],
  
  'mozilla_central': [
    "security/nss",
    "security/coreconf",
    "nsprpub",

    # BSD-licensed
    "dbm",
    
    "other-licenses",
    
    "browser/devtools/highlighter/", # BSD
    "browser/devtools/sourceeditor/orion", # EPL XXXCheck
    "browser/extensions/pdfjs", # MIT
    
    "build/pgo/blueprint", # MIT/GPL
    
    # Other directories we want to exclude
    "embedding/tests",     # Agreed as BSD
    "gfx/cairo",           # LGPL/MPL
    "gfx/graphite2",       # LGPL leading, with MPL and GPL alternatives
    "gfx/angle",           # BSD
    "gfx/harfbuzz",        # Permissive, BSD-like
    "gfx/ots",             # BSD
    "gfx/qcms",            # MIT
    "gfx/skia",            # BSD
    "gfx/ycbcr",           # BSD

    "extensions/spellcheck/hunspell", # MPL/LGPL/GPL, but not ours

    # mkdepend - BSD
    "config/mkdepend",
    "js/src/config/mkdepend",
    "security/coreconf/mkdepend",
    
    "browser/app/profile/extensions/testpilot@labs.mozilla.com/content/flot", # Copy of jquery
    "build/pgo/js-input", # SunSpider - Apple BSD
    "content/canvas/test/webgl", # WebGL test suite - BSD
    "db/sqlite3", # Public Domain
    
    "dom/plugins/test/testplugin", # BSD
    "dom/tests/mochitest/ajax", # Various Ajax libraries, all MIT
    "dom/tests/mochitest/dom-level1-core", # W3C
    "dom/tests/mochitest/dom-level2-core", # W3C
    "dom/tests/mochitest/dom-level2-html", # W3C

    "editor/libeditor/html/tests/browserscope/lib/richtext2", # Apache

    "intl/hyphenation", # tri-licensed but prob. not us; Bug 716482
    
    "ipc/chromium/base",   # BSD
    "ipc/chromium/src",    # BSD

    "js/src/assembler/assembler",    # BSD
    "js/src/assembler/jit",          # BSD
    "js/src/assembler/wtf",          # BSD
    "js/src/ctypes/libffi",          # MIT
    "js/src/jit-test/tests/sunspider", # BSD
    "js/src/metrics/jint/sunspider",   # BSD
    "js/src/jit-test/tests/v8-v5",   # BSD
    "js/src/metrics/jint/v8",        # BSD
    "js/src/v8",                     # BSD
    "js/src/v8-dtoa",                # BSD
    "js/src/yarr",                   # BSD

    "media/libjpeg",
    "media/libpng",
    "media/libnestegg", # BSD/ISC
    "media/libogg",     # BSD
    "media/libtheora",  # BSD
    "media/libtremor",  # BSD    
    "media/libvorbis",  # BSD
    "media/libvpx",     # BSD
    "media/libcubeb",   # MIT
    "media/libopus",    # BSD
    "media/libspeex_resampler", # BSD
    
    "memory/jemalloc",  # BSD

    "mfbt/double-conversion", # BSD
    
    "mobile/android/base/apache/commons/codec", # Apache
    "mobile/android/base/httpclientandroidlib", # Apache
    "mobile/android/base/json-simple",
    
    "modules/freetype2",  # FreeType License
    "modules/libbz2/src", # BSD
    "modules/zlib",
    "security/nss/lib/zlib",

    "parser/expat", # MIT
    "parser/html",  # MIT
    
    "testing/mochitest/MochiKit", # MIT
    "testing/mochitest/tests/MochiKit-1.4.2/MochiKit", # MIT
    "testing/mochitest/pywebsocket", # BSD
    
    "toolkit/components/alerts/mac/growl", # BSD
    "toolkit/crashreporter/google-breakpad", # BSD
    
    "tools/profiler/libunwind", # MIT
  ],

  'camino': [
    # Camino
    "sparkle", # MIT
    "google-breakpad", # BSD
    "growl", # BSD
    "striptease", # APSL build tool
    "flashblock", # Upstream tri-licence
  ],

  'addon_sdk': [
    # Addon SDK
    "python-lib/markdown", # BSD
    "python-lib/simplejson", # MIT
    "doc/static-files/syntaxhighlighter", # MIT/GPL dual
  ],

  'bugzilla': [
    # Bugzilla
    "lib",
    "data",
    "js/yui",
    "js/history.js", # Yes, this is a directory
  ],

  'browserid': [
    # BrowserID
    "resources/static/lib", # Need to check manually
  ],

  'elmo': [
    # elmo
    "static/simile",
    "static/js/jquery.ui",
    "static/css/jquery.ui",
    "static/js/libs",
    "vendor-local",
  ],

  'socorro': [
    # Socorro
    "puppet",
    "docs",
    "webapp-php/js/jquery",
    "webapp-php/js/flot-0.7",
    "webapp-php/modules/ezcomponents/libraries/Feed",
    "webapp-php/modules/ezcomponents/libraries/Base",
    "webapp-php/modules/flot",
    "webapp-php/modules/forge",
    "webapp-php/system/core",
    "webapp-php/system/i18n",
    "webapp-php/system/views",
    "webapp-php/system/helpers",
    "webapp-php/system/libraries",
  ],

  'comm-central': [
    # comm-central
    "other-licenses",
    "calendar/libical", # MPL/LGPL
    "mozilla",
    "build/pypng",  
    
    "mail/test/resources/virtualenv",
    "mail/test/resources/simplejson-2.1.6",  
  ],
  
  'rhino': [
    "testsrc/benchmarks/sunspider-0.9.1",
    "testsrc/benchmarks/v8-benchmarks-v5",
    "testsrc/benchmarks/v8-benchmarks-v6",
    "src/org/mozilla/javascript/v8dtoa",
    "toolsrc/org/mozilla/javascript/tools/debugger/treetable",
    "testsrc/org/mozilla/javascript/tests/commonjs",
  ],
  
  'instantbird': [
    "purple/config",
    "purple/icons",
    "purple/libpurple",
    "purple/libraries",
    "purple/locales",
    "other-licenses",
  ],
}

_g_skip_dirs = get_config(_g_skip_dirs_config, treename)

_g_basename_to_comment_info = {
    "configure": (["dnl"], ),

    "Makefile": (["#"], ),
    "makefile": (["#"], ),
    "nfspwd": (["#"], ),
    "typemap": (["#"], ),
    "xmplflt.conf": (["#"], ),
    "ldapfriendly": (["#"], ),
    "ldaptemplates.conf": (["#"], ),
    "ldapsearchprefs.conf": (["#"], ),
    "ldapfilter.conf": (["#"], ),
    "README.configure": (["#"], ),
    "Options.txt": (["#"], ),
    "fdsetsize.txt": (["#"], ),
    "prototype": (["#"], ),
    "prototype_i386": (["#"], ),
    "prototype3_i386": (["#"], ),
    "prototype_com": (["#"], ),
    "prototype3_com": (["#"], ),
    "prototype_sparc": (["#"], ),
    "prototype3_sparc": (["#"], ),
    "nglayout.mac": (["#"], ),
    "pkgdepend": (["#"], ),
    "Maketests": (["#"], ),
    "depend": (["#"], ),
    "csh-aliases": (["#"], ),
    "csh-env": (["#"], ),
    ".cshrc": (["#"], ),
    "MANIFEST": (["#"], ),
    "mozconfig": (["#"], ),
    "makecommon": (["#"], ),
    "bld_awk_pkginfo": (["#"], ),
    "prototype_i86pc": (["#"], ),
    "pkgdepend_5_6": (["#"], ),
    "awk_pkginfo-i386": (["#"], ),
    "awk_pkginfo-sparc": (["#"], ),
    "pkgdepend_64bit": (["#"], ),
    "WIN32": (["#"], ),
    "WIN16": (["#"], ),
    "Makefile.linux": (["#"], ),
    "ignored": (["#"], ),

    "README": ([""], ["#"]),
    "copyright": ([""], ),

    "xptcstubs_asm_ppc_darwin.s.m4": (["/*", "*", "*/"], ),
    "xptcstubs_asm_mips.s.m4": (["/*", "*", "*/"], ),

    "nsIDocCharsetTest.txt": (["<!--", "-", "-->"], ),
    "nsIFontListTest.txt": (["<!--", "-", "-->"], ),
    "ComponentListTest.txt": (["<!--", "-", "-->"], ),
    "nsIWebBrowserPersistTest1.txt": (["<!--", "-", "-->"], ),
    "nsIWebBrowserPersistTest2.txt": (["<!--", "-", "-->"], ),
    "nsIWebBrowserPersistTest3.txt": (["<!--", "-", "-->"], ),
    "plugins.txt": (["<!--", "-", "-->"], ),
    "NsISHistoryTestCase1.txt": (["<!--", "-", "-->"], ),
    "EmbedSmokeTest.txt": (["<!--", "-", "-->"], ),

    "lineterm_LICENSE": (["/*", "*", "*/"], ),
    "XMLterm_LICENSE": (["/*", "*", "*/"], ),
    "BrowserView.cpp.mod": (["/*", "*", "*/"], ),
    "header_template": (["/*", "*", "*/"], ),
    "cpp_template": (["/*", "*", "*/"], ),

    "abcFormat470.txt": (["//"], ),
    "opcodes.tbl": (["//"], ),

    "package-manifest":  ([";"], ),
}

_g_ext_to_comment_info = {
    ".txt":   (["##", "#", ], ["#"]),
    ".TXT":   (["##", "#", ]),

    ".doc":   (["", ]),
    ".build": (["", ]),
    ".1st":   (["", ]),
    ".lsm":   (["", ]),
    ".FP":    (["", ]),
    ".spec":  (["", ]),

    ".CPP":    (["/*", "*", "*/"], ),
    ".cpp":    (["/*", "*", "*/"], ),
    ".H":      (["/*", "*", "*/"], ),
    ".h":      (["/*", "*", "*/"], ),
    ".hxx":    (["/*", "*", "*/"], ),
    ".c":      (["/*", "*", "*/"], ),
    ".css":    (["/*", "*", "*/"], ['#']),
    ".js":     (["/*", "*", "*/"], ['#']),
    ".idl":    (["/*", "*", "*/"], ),
    ".ut":     (["/*", "*", "*/"], ),
    ".rc":     (["/*", "*", "*/"], ),
    ".rc2":    (["/*", "*", "*/"], ),
    ".RC":     (["/*", "*", "*/"], ),
    ".Prefix": (["/*", "*", "*/"], ),
    ".prefix": (["/*", "*", "*/"], ),
    ".cfg":    (["/*", "*", "*/"], ["#"]),
    ".cp":     (["/*", "*", "*/"], ),
    ".cs":     (["/*", "*", "*/"], ),
    ".java":   (["/*", "*", "*/"], ),
    ".jst":    (["/*", "*", "*/"], ),
    ".tbl":    (["/*", "*", "*/"], ),
    ".tab":    (["/*", "*", "*/"], ),
    ".cc":     (["/*", "*", "*/"], ),
    ".msg":    (["/*", "*", "*/"], ),
    ".y":      (["/*", "*", "*/"], ),
    ".r":      (["/*", "*", "*/"], ),
    ".mm":     (["/*", "*", "*/"], ),
    ".x-ccmap":(["/*", "*", "*/"], ),
    ".ccmap":  (["/*", "*", "*/"], ),
    ".sql":    (["/*", "*", "*/"], ),
    ".pch++":  (["/*", "*", "*/"], ),
    ".xpm":    (["/*", "*", "*/"], ),
    ".uih":    (["/*", "*", "*/"], ),
    ".uil":    (["/*", "*", "*/"], ),
    ".ccmap":  (["/*", "*", "*/"], ),
    ".map":    (["/*", "*", "*/"], ),
    ".win98":  (["/*", "*", "*/"], ),
    ".php":    (["/*", "*", "*/"], ),
    ".php-dist": (["/*", "*", "*/"], ),
    ".m":      (["/*", "*", "*/"], ),
    ".jnot":   (["/*", "*", "*/"], ),
    ".l":      (["/*", "*", "*/"], ),
    ".htp":    (["/*", "*", "*/"], ),
    ".xs":     (["/*", "*", "*/"], ),
    ".as":     (["/*", "*", "*/"], ),
    ".jsm":    (["/*", "*", "*/"], ),
    ".dep":    (["/*", "*", "*/"], ),
    ".sjs":    (["/*", "*", "*/"], ),
    ".ipdl":   (["/*", "*", "*/"], ),
    ".d":      (["/*", "*", "*/"], ),
    ".strings":(["/*", "*", "*/"], ),
    ".uf":     (["/*", "*", "*/"], ),
    ".dox":    (["/*", "*", "*/"], ),
    ".abs":    (["/*", "*", "*/"], ),
    ".es":     (["/*", "*", "*/"], ),
    ".hh":     (["/*", "*", "*/"], ),
    ".pig":    (["/*", "*", "*/"], ),
    
    ".api":    (["/*", "*", "*/"], ['#']),
    ".applescript": (["(*", "*", "*)"], ["--"], ["#"]),

    ".xcconfig": (["//"], ),
    ".st":       (["//"], ),
    ".doctest":  (["//"], ),
    ".jstest":   (["//"], ),

    ".html": (["<!--", "-", "-->"], ["#"]),
    ".xml":  (["<!--", "-", "-->"], ["#"]),
    ".xbl":  (["<!--", "-", "-->"], ["#"]),
    ".xsl":  (["<!--", "-", "-->"], ),
    ".xul":  (["<!--", "-", "-->"], ["#"]),
    ".dtd":  (["<!--", "-", "-->"], ["#"]),
    ".rdf":  (["<!--", "-", "-->"], ["#"]),
    ".htm":  (["<!--", "-", "-->"], ),
    ".out":  (["<!--", "-", "-->"], ),
    ".resx": (["<!--", "-", "-->"], ),
    ".bl":   (["<!--", "-", "-->"], ),
    ".xif":  (["<!--", "-", "-->"], ),
    ".xhtml":(["<!--", "-", "-->"], ["#"]),
    ".svg":  (["<!--", "-", "-->"], ),
    ".ttx":  (["<!--", "-", "-->"], ),
    ".atom": (["<!--", "-", "-->"], ),
    ".md":   (["<!--", "-", "-->"], ),
    ".table":(["<!--", "-", "-->"], ),
    ".ejs":  (["<!--", "-", "-->"], ),

    ".inc":  (["<!--", "-", "-->"], 
              ["#"],
              ["@!"],
              ["/*", "*", "*/"]),

    ".properties": (["#"], ),
    ".win":        (["#"], ),
    ".dsp":        (["#"], ),
    ".exp":        (["#"], ),
    ".mk":         (["#"], ),
    ".mn":         (["#"], ),
    ".mak":        (["#"], ),
    ".MAK":        (["#"], ),
    ".perl":       (["#"], ),
    ".pl":         (["#"], ),
    ".PL":         (["#"], ),
    ".sh":         (["#"], ),
    ".dsw":        (["#"], ),
    ".cgi":        (["#"], ),
    ".pm":         (["#"], ),
    ".pod":        (["#"], ),
    ".src":        (["#"], ),
    ".csh":        (["#"], ),
    ".DLLs":       (["#"], ),
    ".ksh":        (["#"], ),
    ".toc":        (["#"], ),
    ".am":         (["#"], ),
    ".df":         (["#"], ),
    ".client":     (["#"], ),
    ".ref":        (["#"], ), # all of them "Makefile.ref"
    ".ldif":       (["#"], ),
    ".ex":         (["#"], ),
    ".reg":        (["#"], ),
    ".py":         (["#"], ),
    ".adb":        (["#"], ),
    ".dtksh":      (["#"], ),
    ".et":         (["#"], ),
    ".stub":       (["#"], ),
    ".nss":        (["#"], ),
    ".os2":        (["#"], ),
    ".Solaris":    (["#"], ),
    ".rep":        (["#"], ),
    ".NSS":        (["#"], ),
    ".server":     (["#"], ),
    ".awk":        (["#"], ),
    ".targ":       (["#"], ),
    ".gnuplot":    (["#"], ),
    ".bash":       (["#"], ),
    ".com":        (["#"], ),
    ".dat":        (["#"], ),
    ".rpm":        (["#"], ),
    ".nsi":        (["#"], ),
    ".nsh":        (["#"], ),
    ".template":   (["#"], ),
    ".ldkd":       (["#"], ),
    ".ldku":       (["#"], ),
    ".arm":        (["#"], ),
    ".qsconf":     (["#"], ),
    ".list":       (["#"], ),
    ".aff":        (["#"], ),
    ".common":     (["#"], ),
    ".manifest":   (["#"], ["<!--", "-", "-->"], ),
    ".excl":       (["#"], ),
    ".yaml":       (["#"], ),
    ".tac":        (["#"], ),
    ".pp":         (["#"], ),

    ".tdf":  ([";"], ),
    ".def":  ([";+#"], [";"]),
    ".DEF":  ([";+#"], [";"]),
    ".ini":  ([";"], ),
    ".it":   ([";"], ),
    ".lisp": ([";;;"], ),

    ".cmd": (["REM"], ["rem"]),
    ".bat": (["REM"], ["rem"]),

    ".tex":  (["%"], ),
    ".texi": (["%"], ),

    ".m4":  (["dnl"], ),

    ".asm": ([";"], ),
    ".vbs": (["'"], ),
    ".il":  (["!"], ),
    ".ad":  (["!"], ),

    ".script": (["(*", " *", "*)"], ),

    ".3x":  (['.\\"'], ),
        
    ".rst": ([".."], ),
    
    # What a mess...
    ".s": (["#"], ["//"], ["/*", "*", "*/"], ["!"], [";"], ["/"]),

    # Bugzilla
    ".tmpl":       (["[%#", "#", "#%]"], ["#"], ),
    ".t":          (["#"], ),
    ".conf":       (["#"], ),
}
_g_shebang_pattern_to_comment_info = [
    (re.compile(ur'\A#!.*/bin/(ba)?sh.*$', re.IGNORECASE), (["#"], )),
    (re.compile(ur'\A#!.*perl.*$', re.IGNORECASE), (["#"], )),
    (re.compile(ur'\A#!.*php.*$', re.IGNORECASE), (["#"], )),
    (re.compile(ur'\A#!.*python.*$', re.IGNORECASE), (["#"], )),
    (re.compile(ur'\A#!.*ruby.*$', re.IGNORECASE), (["#"], )),
    (re.compile(ur'\A#!.*tclsh.*$', re.IGNORECASE), (["#"], )),
    (re.compile(ur'\A#!.*wish.*$', re.IGNORECASE), (["#"], )),
    (re.compile(ur'\A#!.*expect.*$', re.IGNORECASE), (["#"], )),
    (re.compile(ur'\A#!.*env node.*$', re.IGNORECASE), (["/*", "*", "*/"], )),
]


_g_newlicense = """\
This Source Code Form is subject to the terms of the Mozilla Public
License, v. 2.0. If a copy of the MPL was not distributed with this
file, You can obtain one at http://mozilla.org/MPL/2.0/."""

_g_incompatible = """

This Source Code Form is "Incompatible With Secondary Licenses", as
defined by the Mozilla Public License, v. 2.0."""

_g_dry_run = 0 # if true, don't modify any files
_g_force = 0 # if true, continue after errors
_g_check_all = 0
_g_fast_binary = 1 # if true, do a simple check on files to see if binary
                   # if false, do a slow check using the 'file' command
_g_mode = "report"
_g_add_incompatible = 0

#---- internal support routines


def _is_binary(filename):
    """Return true iff the given filename is binary.

    Raises an EnvironmentError if the file does not exist or cannot be
    accessed.
    """
    if not _g_fast_binary:
        # http://stackoverflow.com/questions/898669/how-can-i-detect-if-a-file-is-binary-non-text-in-python
        return (re.search(r':.* text',
                          subprocess.Popen(["file", '-L', filename], 
                                           stdout=subprocess.PIPE).stdout.read())
                is None)
    
    fin = open(filename, 'rb')
    try:
        CHUNKSIZE = 1024
        while 1:
            chunk = fin.read(CHUNKSIZE)
            if '\0' in chunk: # found null byte
                return 1
            if len(chunk) < CHUNKSIZE:
                break # done
    finally:
        fin.close()

    return 0


_g_cvsignore_cache = {} # optimization: keep a cache of .cvsignore content
def _should_skip_according_to_cvsignore(path):
    dirname, basename = os.path.split(path)
    cvsignore = os.path.join(dirname, ".cvsignore")
    if not os.path.exists(cvsignore):
        return 0
    elif cvsignore not in _g_cvsignore_cache:
        fin = open(cvsignore, 'r')
        to_ignore = []
        try:
            for f in fin:
                if f[-1] == "\n": f = f[:-1] # chomp
                if not f: continue # skip empty lines
                to_ignore.append(f)
        finally:
            fin.close()
        _g_cvsignore_cache[cvsignore] = to_ignore

    # At this point .cvsignore exists and its contents are in the cache.
    to_ignore = _g_cvsignore_cache[cvsignore]
    if basename in to_ignore:
        return 1
    else:
        return 0

_g_backup_pattern = re.compile("~\d+$")
def _should_skip_file(path):
    log.debug("_should_skip_file(path='%s')", path)
    if _g_check_all:
        return 0
    ext = os.path.splitext(path)[1]
    if ext in _g_skip_exts:
        log.info("Skipping '%s' (according to '_g_skip_exts').", path)
        return 1
    xpath = '/'.join(path.split(os.sep)) # use same sep as in _g_skip_files
    for sf in _g_skip_files:
        if xpath.endswith(sf):
            log.info("Skipping '%s' (according to '_g_skip_files').", path)
            return 1
    if os.path.basename(path) in _g_skip_file_basenames:
        log.info("Skipping '%s' (according to '_g_skip_file_basenames').", path)
        return 1
    if _should_skip_according_to_cvsignore(path):
        log.info("Skipping '%s' (according to .cvsignore).", path)
        return 1
    if _g_backup_pattern.search(path):
        log.info("Skipping '%s' (looks like backup file).", path)
        return 1
    return 0

def _should_skip_dir(path):
    log.debug("_should_skip_dir(path='%s')", path)
    if os.path.basename(path) in _g_skip_dir_basenames:
        log.info("Skipping '%s' (according to _g_skip_dir_basenames).", path)
        return 1
    
    if _g_check_all:
        return 0
    
    if _g_mode == "add" and os.path.basename(path) in _g_skip_add_dir_basenames:
        log.info("Skipping '%s' (according to _g_skip_add_dir_basenames).", path)
        return 1        
    xpath = '/'.join(path.split(os.sep)) # use same sep as in _g_skip_dirs
    # These could do with being a proper path canonicalisation function...
    if xpath[-1] == '/': xpath = xpath[:-1]  # treat "calendar/" the same as "calendar"
    if xpath[0:2] == './': xpath = xpath[2:]  # treat "./calendar" the same as "calendar"
    for sd in _g_skip_dirs:
        # Changed by gerv to make skip_dirs require whole path
        if xpath == sd:
            log.info("Skipping '%s' (according to _g_skip_dirs).", path)
            return 1
    if _should_skip_according_to_cvsignore(path):
        log.info("Skipping '%s' (according to .cvsignore).", path)
        return 1
    return 0


def _get_license_info(filename, quick=0):
    """Return license block information for the given file.

        "filename" is the path to the file to scan.
        "quick" is a boolean that can be set for a quick scan. In this
            case, only the "parts" field of the return dictionary will
            be filled out.
    
    Returns a dictionary adequately describing the license block in the
    given file for the purpose of determining whether to patch the
    license block and how. Returns a dictionary of the following form:
        {"parts": <list of zero or more of "mpl", "npl", "gpl", "lgpl", "pd",
                   "mpl2", "unknown", "block_begin", "block_end" in the
                   order in which they were found>,
         # if necessary, the following keys are included as well
         "begin_line": <(0-based) index at which license block starts>,
         "end_line": <(0-based) index at which license block ends>,
         "first_prefix": <prefix to use for new license block first line>,
         "subsequent_prefix": <prefix to use for subsequent lines>,
         "last_suffix": <suffix to use for last line>,
        }

    precondition: should not be called on binary files
    """
    lic_info = {
        "parts": [],
    }

    fin = open(filename, 'r')
    try:
        content = fin.read()
    finally:
        fin.close()
    
    # Help me find filena
    log.info("Next file is: %s", filename)

    # do quick search to see if any of the desired licenses is in here
    # - if it looks like all the parts are there, good, done
    # - if some but not all parts, continue
    parts_pattern = re.compile("""(
        (?P<block_begin>\*\*\*\*\*\ BEGIN\ LICENSE\ BLOCK\ \*\*\*\*\*)
        | (?P<mpl>The\ contents\ of\ this\ file\ are\ subject\ to\ the\ Mozilla)
        | (?P<npl>The\ contents\ of\ this\ file\ are\ subject\ to\ the\ Netscape)
        | (?P<gpl>GNU\ (General\ )?Public\ License)
        | (?P<lgpl>(Library|Lesser)\ General\ Public\ License)
        | (?P<block_end>\*\*\*\*\*\ END\ LICENSE\ BLOCK\ \*\*\*\*\*)
        | (?P<mpl2>This\ Source\ Code\ Form\ is\ subject\ to\ the\ terms\ of)
        | (?P<apache2>Licensed\ under\ the\ Apache\ License,\ Version\ 2\.0)
        | (?P<bsdevil>All\ advertising\ materials\ mentioning)
        | (?P<bsd>Redistribution\ and\ use\ of\ this\ software|
                  Redistribution\ and\ use\ in\ source\ and\ binary\ forms|
                  Licensed\ under\ the\ New\ BSD\ license)
        | (?P<ofl>This\ Font\ Software\ is\ licensed\ under\ the\ SIL\ Open\ Font\ License)
        | (?P<mit>Permission\ is\ hereby\ granted,\ free\ of\ charge)
        | (?P<hpnd>Permission\ to\ use,\ copy,\ modify,\ and\ distribute\ this\ software)
        | (?P<pd>Any\ copyright\ is\ dedicated\ to\ the\ Public\ Domain|
                [Pp]ublic\ [Dd]omain)
        )""",
        re.VERBOSE)
    parts = [] # found license parts in this file
    start = 0
    blocks = 0
    while 1:
        match = parts_pattern.search(content, start)
        if match:
            parts = match.groupdict()
            # Skip this block, if the last license block is more than 1024 chars
            # away (file is probably used for autogeneration of files and has
            # multiple license blocks).
            if start > 0 and lic_info["parts"][0] != "block_begin":
                log.info("Found multiple matches but not tri-license; exit")
                break
            else:
                for part in parts:
                    if parts[part]:
                        lic_info["parts"].append(part)
                        log.info("%s license/delimiter found", part)
                        start = match.end()
                        if part == "block_end":
                            blocks = blocks + 1
                        else:
                            blocks = 0
                        break
                else:
                    raise RelicError("unexpected license part: %r" % parts)
        else:
            break

    # no license block at all
    if not parts:
        # - if not, check to see if License or Copyright shows up in the
        #   file; if so, then error out; if not, skip out
        any_lic_pattern = re.compile("(Copyright|Licen[sc]e|Public\s*Domain)", re.IGNORECASE)
        match = any_lic_pattern.search(content)
        if match:
            lic_info["parts"].append("unknown")
            log.info("unknown license found: %r",
                     content[max(match.start()-20,0):match.end()+20])
        else:
            log.info("no license found")
        return lic_info

    # license block with non-tri-license version headers
    elif lic_info["parts"] == ["block_begin", "block_end"]:
        lic_info["parts"].append("unknown")
        log.info("unknown license found (license block with non-tri-license)")
        return lic_info

    # license block with tri-license version headers   
    elif (lic_info["parts"] == ["block_begin", "mpl", "gpl", "lgpl", "block_end"] or
          lic_info["parts"] == ["block_begin", "npl", "gpl", "lgpl", "block_end"]):
        log.info("tri-license found")
    
    elif (lic_info["parts"] == ["mpl2"]):
        log.info("MPL2 found")
        return lic_info
    
    elif (lic_info["parts"] == ["pd"]):
        log.info("PD found")
        return lic_info
            
    elif (lic_info["parts"] == ["apache2"]):
        log.info("Apache 2 found")
        return lic_info
            
    elif (lic_info["parts"] == ["bsd"]):
        log.info("BSD found")
        return lic_info
            
    elif (lic_info["parts"] == ["mit"]):
        log.info("MIT found")
        return lic_info
            
    elif (lic_info["parts"] == ["hpnd"]):
        log.info("HPND found")
        return lic_info
            
    elif (lic_info["parts"] == ["ofl"]):
        log.info("OFL found")
        return lic_info
            
    elif (lic_info["parts"] == ["bsdevil"]):
        log.info("4-clause BSD found!")
        return lic_info
            
    if quick:
        return lic_info

    # Otherwise, the license needs to be fixed, so gather more detailed
    # information. Here is the algorithm we will use:
    # - find first license line
    # - find the end of this comment block (assumption: from the first
    #   license line to the end of the comment block is the full
    #   license block)
    #   This is a bad assumption in two cases and steps have been taken
    #   to try to deal with those cases:
    #   - There could be a trailing part bit of comment that is
    #     NOT part of the license but is part of the same comment
    #     block. A common example are the:
    #       This Original Code has been modified by IBM...
    #     files (about 130 of them in the moz tree).
    #     (c.f. test_relicense_ibm_copyright_suffix.c)
    #   - Some files have split up the license paragraphs into
    #     multiple comment blocks, e.g.
    #     "mozilla/build/unix/abs2rel.pl":
    #        # The contents of this file are subject to the
    #        # ...
    #        # the License at http://www.mozilla.org/MPL/
    #
    #        # The Initial Developer of the Original Code
    #        # ...
    #        # Rights Reserved.
    #     (c.f. test_relicense_separated_license_comment_blocks.pl)
    # - these are the lines to replace
    # - gather embedded lic data
    # - use second line to determine line prefix
    # ? Should we only allow processing of unknown-delimiter-files with
    #   an option?

    # Get comment delimiter info for this file.
    comment_delim_sets = _get_comment_delim_sets(filename)

    # - find first license line (and determine which set of comment
    #   delimiters are in use)
    lines = content.splitlines()
    for comment_delims in comment_delim_sets:
        if len(comment_delims) == 3:
            # Note: allow for whitespace before continuation character
            prefix_pattern = "%s|\s*%s|" % (re.escape(comment_delims[0]),
                                            re.escape(comment_delims[1]))
            suffix_pattern = "%s" % re.escape(comment_delims[2])
        elif len(comment_delims) == 2:
            prefix_pattern = "%s|" % re.escape(comment_delims[0])
            suffix_pattern = "%s" % re.escape(comment_delims[1])
        elif len(comment_delims) == 1:
            prefix_pattern = re.escape(comment_delims[-1])
            suffix_pattern = ""
        else: # len(comment_delims) == 0
            prefix_pattern = ""
            suffix_pattern = ""

        lic_begin_pattern = re.compile("""
            ^(?P<prefix>%s)
            (?P<space>\s*)
            (\*+\ BEGIN\ LICENSE\ BLOCK\ \*+
             |\-+\ BEGIN\ LICENSE\ BLOCK\ \-+
             | Version:\ MPL\ \d+\.\d+/GPL\ \d+\.\d+/LGPL\ \d+\.\d+
             | The\ contents\ of\ this\ file\ are\ subject\ to\ the\ Mozilla[\w ]*
             | The\ contents\ of\ this\ file\ are\ subject\ to\ the\ Netscape[\w ]*
             | Alternatively,\ the\ contents\ of\ this\ file\ may\ be\ used\ under\ the[\w ]*)
            (?P<suffix>%s|)\s*?$
            """ % (prefix_pattern, suffix_pattern), re.VERBOSE)

        for i in range(len(lines)):
            match = lic_begin_pattern.search(lines[i])
            if match:
                beginline = {
                    "content": lines[i],
                    "linenum": i,
                    "prefix": match.group("prefix"),
                    "space": match.group("space"),
                    "suffix": match.group("suffix")
                }
                # Optimization: If the line before the "beginline" is simply
                # a block comment open the include that line in parsed out
                # license block. E.g.,
                #    <!--
                #       - ***** BEGIN LICENSE BLOCK *****
                #       ...
                if (len(comment_delims) > 1  # only for block comments
                    and beginline["prefix"] != comment_delims[0]
                    and i-1 >= 0
                    and lines[i-1].strip() == comment_delims[0]):
                    beginline["linenum"] -= 1
                    beginline["prefix"] = comment_delims[0]
                break
        if match: break
    else:
        raise RelicError("couldn't find start line with this pattern (even "
                         "though it looks like there is a license block in "
                         "%s): %s" % (filename, lic_begin_pattern.pattern))
    log.info("comment delimiters: %s", comment_delims)
    log.debug("beginline dict: %s", beginline)
    lic_info["comment_delims"] = comment_delims
    lic_info["begin_line"] = beginline["linenum"]
    lic_info["first_prefix"] = beginline["prefix"]
    log.info("prefix for first line: '%s'", beginline["prefix"])

    # - get second license line
    lic_middle_pattern = re.compile("""
        ^(?P<prefix>%s|)
        (?P<space>\s*)
        (?P<content>.*)
        (?P<suffix>%s|)\s*?$
        """ % (prefix_pattern, suffix_pattern),
        re.VERBOSE)
    # skip empty lines which might result in bogus scanning later, e.g.:
    #   mozilla/layout/html/tests/table/marvin/x_thead_align_center.xml
    second_linenum = beginline["linenum"]+1
    while second_linenum < len(lines):
        if lines[second_linenum].strip():
            break
        log.debug("skip blank 'second' line: %d", second_linenum)
        second_linenum +=1
    else:
        raise RelicError("all lines after the first license block line (%d) "
                         "were empty" % (beginline["linenum"]+1))
    match = lic_middle_pattern.search(lines[second_linenum])
    if match:
        secondline = {
            "content": lines[second_linenum],
            "linenum": second_linenum,
            "prefix": match.group("prefix"),
            "space": match.group("space"),
            "suffix": match.group("suffix")
        }
    else:
        raise RelicError("didn't find second line with pattern: %s"
                         % lic_middle_pattern.pattern)
    log.debug("secondline dict: %s", secondline)
    lic_info["subsequent_prefix"] = secondline["prefix"]
    log.info("prefix for subsequent lines: '%s'", secondline["prefix"])

    # - find block comment end
    orig_code_modified_pattern = re.compile("This Original Code has been "
                                            "modified", re.I)
    non_lic_content_in_same_comment_block = 0
    if len(comment_delims) == 1:
        # line-style comments: The comment block "end" is defined as the
        # last line before a line NOT using the block comment delimiter.
        #XXX:BUG: This is not good enough for:
        #           test/inputs/separated_license_comment_blocks.pl
        if comment_delims[0] == "":
            raise RelicError(
                "Don't know how to find the end of a line-style comment "
                "block when the delimiter is the empty string. (Basically "
                "this script cannot handle this type of file.)")
        for i in range(beginline["linenum"]+1, len(lines)):
            if not lines[i].startswith(comment_delims[0]):
                endlinenum = i-1
                break
            elif lines[i].find("END LICENSE BLOCK") != -1:
                endlinenum = i
                break
            # As per "test_relicense_trailing_orig_code_modified.pl", a
            # paragraph starting with:
            #     This Original Code has been modified
            # is deemed to be OUTside the license block, i.e. it is not
            # replaced for relicensing.
            if orig_code_modified_pattern.search(lines[i]):
                non_lic_content_in_same_comment_block = 1
                # The endline is the first non-blank line before this one.
                endlinenum = i-1
                while 1:
                    line = lines[endlinenum]
                    match = lic_middle_pattern.search(line)
                    if not match:
                        raise RelicError("Line did not match lic_middle_pattern "
                                         "unexpectedly: %r" % line)
                    if match.group("content").strip(): # non-empty line
                        break
                    endlinenum -= 1
                break
        else:
            raise RelicError("Could not find license comment block end "
                             "line in '%s'." % filename)
    elif len(comment_delims) >= 2:   # block-style comments
        for i in range(beginline["linenum"]+1, len(lines)):
            if lines[i].find(comment_delims[-1]) != -1:
                endlinenum = i
                break
            elif lines[i].find("END LICENSE BLOCK") != -1:
                endlinenum = i
                non_lic_content_in_same_comment_block = 1
                break
            # As per "test_relicense_ibm_copyright_suffix.c", a
            # paragraph starting with:
            #     This Original Code has been modified
            # is deemed to be OUTside the license block, i.e. it is not
            # replaced for relicensing.
            if orig_code_modified_pattern.search(lines[i]):
                non_lic_content_in_same_comment_block = 1
                # The endline is the first non-blank line before this one.
                endlinenum = i-1
                while 1:
                    line = lines[endlinenum]
                    match = lic_middle_pattern.search(line)
                    if not match:
                        raise RelicError("Line did not match lic_middle_pattern "
                                         "unexpectedly: %r" % line)
                    if match.group("content").strip(): # non-empty line
                        break
                    endlinenum -= 1
                break
        else:
            raise RelicError("Could not find license comment block end "
                             "line in '%s'." % filename)
        if not non_lic_content_in_same_comment_block\
           and not lines[endlinenum].strip().endswith(comment_delims[-1]):
            raise RelicError(
                "There is text AFTER the license block comment end "
                "delimiter, but on the SAME LINE. This is unexpected. "
                "Bailing.\n%s:%s:%r"
                % (filename, endlinenum, lines[endlinenum]))
    else: # len(comment_delims) == 0
        # For files without a comment character to help out, we ONLY
        # successfully break one the full correct "END LICENSE BLOCK"
        # token.
        for i in range(beginline["linenum"]+1, len(lines)):
            if lines[i].find("END LICENSE BLOCK") != -1:
                endlinenum = i
                break
            elif i > beginline["linenum"]+1+50:
                raise RelicError("Haven't found 'END LICENSE BLOCK' marker "
                                 "within 50 lines of the start of the "
                                 "license block on line %d. Aborting." 
                                 % (beginline["linenum"]+1))
            # As per "test_relicense_trailing_orig_code_modified.pl", a
            # paragraph starting with:
            #     This Original Code has been modified
            # is deemed to be OUTside the license block, i.e. it is not
            # replaced for relicensing.
            if orig_code_modified_pattern.search(lines[i]):
                non_lic_content_in_same_comment_block = 1
                # The endline is the first non-blank line before this one.
                endlinenum = i-1
                while 1:
                    line = lines[endlinenum]
                    match = lic_middle_pattern.search(line)
                    if not match:
                        raise RelicError("Line did not match lic_middle_pattern "
                                         "unexpectedly: %r" % line)
                    if match.group("content").strip(): # non-empty line
                        break
                    endlinenum -= 1
                break
        else:
            raise RelicError("Could not find license comment block end "
                             "line in '%s'." % filename)

    # Test case: test_relicense_separated_license_comment_blocks.pl
    # It is possible that a separate comment block immediately following
    # the license block we just parsed should be included in the license
    # block.
    if (not non_lic_content_in_same_comment_block
        and len(comment_delims) == 1): # only do this for line-style comments
        lic_indicators = [
            re.compile("^The content of this file are subject to", re.I),
            re.compile("^Software distributed under the License", re.I),
            re.compile("^The Original Code is", re.I),
            re.compile("^The Initial Developer", re.I),
            re.compile("^Contributor", re.I),
            re.compile("^Alternatively, the content of this file", re.I),
        ]
        comment_line_pattern = re.compile("""
            ^(?P<prefix>%s|)
            (?P<space>\s*)
            (?P<content>.*)
            (?P<suffix>%s|)\s*?$
            """ % (prefix_pattern, suffix_pattern),
            re.VERBOSE)
        i = endlinenum
        while i+1 < len(lines):
            i += 1; line = lines[i]
            comment_index = line.find(comment_delims[0])
            if comment_index != -1:
                content = line[:comment_index].strip()
                comment = line[comment_index+len(comment_delims[0]):].strip()
            else:
                content = line.strip()
                comment = ""
            if content: # if non-comment content, then skip out
                break
            if not comment:
                continue
            for indicator in lic_indicators:
                if indicator.search(comment):
                    # include this paragraph in the lic block
                    while i < len(lines):
                        i += 1; line = lines[i]
                        if not line.strip().startswith(comment_delims[0]):
                            break
                        if not line.strip()[len(comment_delims[0]):]:
                            break
                    endlinenum = i-1
                    break
            else:
                break # this is a non-lic-related comment
    
    # Get the end-line data.
    if non_lic_content_in_same_comment_block:
        lic_end_pattern = re.compile(
            "^(?P<prefix>%s)(?P<space>\s*).*?\s*?$"
            % prefix_pattern)
    else:
        lic_end_pattern = re.compile(
            "^(?P<prefix>%s)(?P<space>\s*).*?(?P<suffix>%s)\s*?$"
            % (prefix_pattern, suffix_pattern))
    match = lic_end_pattern.match(lines[endlinenum])
    if match:
        endline = {
            "content": lines[endlinenum],
            "linenum": endlinenum,
            "prefix": match.group("prefix"),
            "space": match.group("space"),
            "suffix": match.groupdict().get("suffix", ""),
        }
    else:
        raise RelicError("license block end line did not match: line='%s', "
                         "pattern='%s'"
                         % (lines[endlinenum], lic_end_pattern.pattern))
    log.debug("endline dict: %s", endline)
    lic_info["last_suffix"] = endline["suffix"]
    log.info("suffix for last line: '%s'", endline["suffix"])
    lic_info["end_line"] = endline["linenum"]
    log.info("license lines: %d-%d", beginline["linenum"], endline["linenum"])

    # So at this point we have the beginline, secondline, and endline
    # dicts describing and bounding the license block.    
    return lic_info


def _report_on_file(path, (results, quick, _errors)):
    log.debug("_report_on_file(path='%s', results)", path)
    output = path + "\n"
    lic_info = {}
    
    if _is_binary(path):
        output += "... binary, skipping this file\n"
    else:
        try:
            lic_info = _get_license_info(path, quick)
        except RelicError, ex:
            return _relicensing_error(ex, path, _errors)
    
        if log.isEnabledFor(logging.DEBUG):
            pprint.pprint(lic_info)
        parts = lic_info["parts"]
        if not parts:
            output += "... no license found\n"
        elif "unknown" in parts:
            output += "... unknown license (possibly) found\n"
        elif ((parts == ["block_begin", "mpl", "gpl", "lgpl", "block_end"] or
               parts == ["block_begin", "npl", "gpl", "lgpl", "block_end"]) and
              not lic_info.get("unindented_contributor_lines")):
            output += "... %s found (looks complete)"\
                      % "/".join(parts) + "\n"
        else:
            output += "... %s found" % "/".join(parts) + "\n"

        if not quick:
            if "begin_line" in lic_info and "end_line" in lic_info:
                output += "... license block lines: %(begin_line)d-%(end_line)d"\
                  % lic_info + "\n"
            if "original_code_is" in lic_info:
                output += "... original code is: %(original_code_is)s"\
                  % lic_info + "\n"
            if "original_code_date" in lic_info:
                output += "... original code date: %(original_code_date)s"\
                      % lic_info + "\n"
            if "initial_developer" in lic_info:
                output += "... initial developer: %(initial_developer)s"\
                      % lic_info + "\n"
            if "initial_copyright_date" in lic_info:
                output += "... initial copyright date: %(initial_copyright_date)s"\
                      % lic_info + "\n"
            if "contributors" in lic_info:
                output += "... contributors: %s"\
                  % ", ".join(lic_info["contributors"]) + "\n"
            if lic_info.get("unindented_contributor_lines"):
                output += "... one or more contributor lines were not indented properly"\
                      + "\n"

    print output;

def _gather_info_on_file(path, (results, _errors)):
    log.debug("_gather_info_on_file(path='%s', results)", path)
    # Skip binary files.
    try:
        if _is_binary(path):
            log.debug("Skipping binary file '%s'.", path)
            return
    except Exception, ex:
        return _relicensing_error(
            "error determining if file is binary: %s" % ex,
            path, _errors)

    try:
        results[path] = _get_license_info(path)
    except RelicError, ex:
        return _relicensing_error(ex, path, _errors, 1)


def _make_backup_path(path):
    for n in range(100):
        backup_path = "%s~%d" % (path, n)
        if not os.path.exists(backup_path):
            return backup_path
    raise RelicError("Could not find an unused backup path for '%s'." % path)


def _relicensing_error(err, path, cache=None, quiet=1):
    """Handle an error during relicensing.
    
        "err" may be an error string or an exception instance.
        "path" is the path of the file on which this error occured.
        "cache" is a mapping of path to errors on which errors may be
            stored for later reporting.
        "quiet" optionally allows one to silence the stdout output when
            force is in effect.

    If the --force option is in-effect then errors may be remembered and
    processing continues, rather than halting the whole process.
    """
    if _g_force:
        if not quiet:
            print "...", err
        if cache is not None:
            cache[path] = err
    elif isinstance(err, Exception):
        raise
    else:
        raise RelicError("%s: %s" % (path, err))


def _get_true_filename(filename):
    if os.path.splitext(filename)[1] in _g_strip_exts:
        # Strip extensions which hide the real extension. E.g. 
        # "<foo>.in" is generally a precursor for a filetype
        # identifiable without the ".in". Drop it.
        xfilename = os.path.splitext(filename)[0]
    else:
        xfilename = filename
    
    return xfilename
    
def _get_comment_delim_sets(filename):
    comment_delims = None
    xfilename = _get_true_filename(filename)
    
    # special cases for some basenames
    basename = os.path.basename(xfilename)
    try:
        comment_delims = _g_basename_to_comment_info[basename]
    except KeyError:
        pass
    if not comment_delims: # use the file extension
        ext = os.path.splitext(xfilename)[1]
        try:
            comment_delims = _g_ext_to_comment_info[ext]
        except KeyError:
            pass
    if not comment_delims: # try to use the shebang line, if any
        fin = open(filename, 'r')
        firstline = fin.readline()
        fin.close()
        if firstline.startswith("#!"):
            for pattern, cds in _g_shebang_pattern_to_comment_info:
                if pattern.match(firstline):
                    comment_delims = cds
                    break
    if not comment_delims:
        raise RelicError("%s: couldn't determine file type (and "
            "comment delimiter info) from basename '%s' or "
            "extension '%s'): you may need to add to "
            "'_g_basename_to_comment_info', "
            "'_g_ext_to_comment_info', "
            "'_g_shebang_pattern_to_comment_info' "
            "or one of the '_g_skip_*' globals"
            % (filename, basename, ext))
    return comment_delims
    

def _relicense_file(original_path,
                    (backup,
                     results,
                     _errors)):
    """Relicense the given file.

        "original_path" is the file to relicense
        "backup" (optional, default false) is a boolean indicating if
            backups should be made
        "results" is a dictionary in which to store statistics and errors.
            See relicense() for schema.
        "_errors" is a dictionary on which errors are reported
            (keyed by file path) when the force option is in effect.

    The function does not return anything.
    """
    log.debug("_relicense_file(original_path='%s')", original_path)
    print original_path

    # Ensure can access file.
    if not os.access(original_path, os.R_OK|os.W_OK):
        return _relicensing_error("cannot access", original_path, _errors)
    else:
        log.info("have read/write access")

    # Skip binary files.
    try:
        if _is_binary(original_path):
            print "... binary, skipping this file"
            results["binary"] += 1
            return
    except Exception, ex:
        return _relicensing_error(
            "error determining if file is binary: %s" % ex,
            original_path, _errors)

    try:
        lic_info = _get_license_info(original_path, 0)
    except RelicError, ex:
        return _relicensing_error(ex, original_path, _errors)

    # Return/abort if cannot or do not need to re-license.
    parts = lic_info["parts"]
    if not parts:
        results["no license"] += 1
        print "... no license found, skipping this file"
        return
    elif "unknown" in parts:
        return _relicensing_error("unknown license (possibly) found",
                                  original_path, _errors)
    elif parts.count("block_begin") > 1: # sanity check
        return _relicensing_error(
            "'BEGIN LICENSE BLOCK' delimiter found more than once",
            original_path, _errors)
    elif parts.count("block_end") > 1: # sanity check
        return _relicensing_error(
            "'END LICENSE BLOCK' delimiter found more than once",
            original_path, _errors)
    elif parts == ["mpl2"]:
            results["good"] += 1
            print "... %s found (looks complete), nothing to do"\
                  % "/".join(parts)
            return        
    elif not (parts == ["block_begin", "mpl", "gpl", "lgpl", "block_end"] or
              parts == ["block_begin", "npl", "gpl", "lgpl", "block_end"] or
              parts == ["block_begin", "mpl", "gpl", "block_end"] or # Rhino
              parts == ["npl"] or # There are a few NPLed files; fix them too
              parts == ["mpl"]):
        # Not sure what this is - return
        print "... %s found (not tri-license, so doing nothing)"\
              % "/".join(parts)
        return
        
    # We need to re-license this file.
    print "... %s found, need to relicense" % "/".join(parts)

    # Put the license block together.
    newlicense = _g_newlicense

    if parts == ["mpl"]:
        newlicense = newlicense + _g_incompatible

    # get fallback comment subsequent prefix
    fallback_prefix = _get_comment_delim_sets(original_path)

    # - add the comment delimiters
    lines = newlicense.splitlines()
    for i in range(len(lines)):
        if i == 0:
            prefix = lic_info["first_prefix"]
        else:
            if lic_info["subsequent_prefix"]:
                prefix = lic_info["subsequent_prefix"]
                # Fix broken block indentations for Bugzilla
                if prefix == "  *":
                    prefix = " *"
            else:
                if len(fallback_prefix[0]) > 0:
                    spaces = ""
                    if len(fallback_prefix[0]) > 1:
                        # Block comments; need to indent. Generate padding
                        # spaces equivalent to length of opening delim, -1
                        spaces = fallback_prefix[0][0]
                        spaces = re.sub(".", " ", spaces)
                        spaces = spaces[:-1]
        
                        prefix = spaces + fallback_prefix[0][1]
                    else:
                        # Line comments
                        prefix = fallback_prefix[0]
                else:
                    prefix = ""
        if lines[i]:
            if len(lic_info["comment_delims"]) == 0:
                lines[i] = prefix + lines[i]
            else:
                lines[i] = prefix + ' ' + lines[i]
        else: # don't add trailing whitespace
            lines[i] = prefix

    
    if lic_info["last_suffix"]: # don't add that ' ' if there is no suffix
        # Ick.
        if lic_info["last_suffix"] == "#%]":
            lines[-1] += '\n  ' + lic_info["last_suffix"]
#        elif lic_info["last_suffix"] == "*/":
#            lines[-1] += '\n ' + lic_info["last_suffix"]
        else:
            lines[-1] += ' ' + lic_info["last_suffix"]

    newlicense_lines = lines

    # Skip out now if doing a dry-run.
    if _g_dry_run:
        results["relicensed"] += 1
        return

    # Make a backup.
    if backup:
        backup_path = _make_backup_path(original_path)
        print "... backing up to '%s'" % backup_path
        try:
            shutil.copy(original_path, backup_path)
        except EnvironmentError, ex:
            return _relicensing_error(ex, original_path, _errors)

    # Re-license the file.
    try:
        fin = open(original_path, "r")
        try:
            lines = fin.readlines()
        finally:
            fin.close()

        # Add EOL character
        eol = "\n"
        if re.search("\r\n", lines[0]):
            eol = "\r\n"
        
        for i in range(len(newlicense_lines)): newlicense_lines[i] += eol

        ##### uncomment to debug license block
        # pprint.pprint(lines)
        # return

        lines[lic_info["begin_line"]:lic_info["end_line"]+1] = newlicense_lines

        fout = open(original_path, "w")
        try:
            fout.write(''.join(lines))
        finally:
            fout.close()
        results["relicensed"] += 1
        print "... done relicensing '%s'" % original_path
    except:
        if backup:
            print "... error relicensing, restoring original"
            if os.path.exists(original_path):
                os.remove(original_path)
            os.rename(backup_path, original_path)
        else:
            print "... error relicensing, file may be corrupted"
        # fallback to type_ for string exceptions
        type_, value, tb = sys.exc_info()
        return _relicensing_error(value or type_,
                                  original_path, _errors)


def _add_license_to_file(original_path,
                         (backup,
                          results,
                          _errors)):
    """Relicense the given file.

        "original_path" is the file to relicense
        "backup" (optional, default false) is a boolean indicating if
            backups should be made
        "results" is a dictionary in which to store statistics and errors.
            See relicense() for schema.
        "_errors" is a dictionary on which errors are reported
            (keyed by file path) when the force option is in effect.
    """
    log.debug("_add_license_to_file(original_path='%s')", original_path)
    print original_path

    results["total"] += 1

    # Ensure can access file.
    if not os.access(original_path, os.R_OK|os.W_OK):
        return _relicensing_error("cannot access", original_path, _errors)
    else:
        log.info("have read/write access")

    # Skip binary files.
    try:
        if _is_binary(original_path):
            print "... binary, skipping this file"
            results["binary"] += 1
            return
    except Exception, ex:
        return _relicensing_error(
            "error determining if file is binary: %s" % ex,
            original_path, _errors)

    ext = os.path.splitext(_get_true_filename(original_path))[1]
    if ext in _g_skip_add_exts:
        print "... not adding license to %s files" % ext
        results["badext"] += 1
        return

    try:
        lic_info = _get_license_info(original_path, 0)
    except RelicError, ex:
        return _relicensing_error(ex, original_path, _errors)

    # Return/abort if cannot or do not need to re-license.
    parts = lic_info["parts"]
    if lic_info["parts"]: # has a license
        print "... license found, skipping this file"
        results["license"] += 1
        return
    #... else we need to add a license to this file.
    print "... no license found, need to add one"

    # Determine what line we can start putting the license block on.
    # Typically this would be line 0, but for the following exceptions:
    # - Shebang (#!) lines
    # - Emacs local variables line:
    #     /* -*- Mode: C++; ... -*- */
    #   This line does not HAVE to be first, but that seems to be a
    #   trend, so might as well honour it.
    # - XML magic "number":  <?xml version="2.0" ... ?>
    #   where "..." might include newlines
    # - @echo off lines
    startline = 0
    try:
        comment_delim_sets = _get_comment_delim_sets(original_path)
    except RelicError, ex:
        return _relicensing_error(ex, original_path, _errors, 1)
    fin = open(original_path, 'r')
    try:
        lines = fin.readlines()
    finally:
        fin.close()

    if not lines:
        print "... empty, skipping this file"
        results["empty"] += 1
        return

    # Advance past a preprocessor filter directive, which can come even
    # before the XML prologue
    if lines and lines[0].find("#filter") != -1:
        startline += 1
            
    # If this is an XML file, advance past the magic number tag.
    if lines and lines[startline].find("<?xml") != -1:
        line = lines[startline]
        if (line.find('encoding="utf-8"') != -1
            and line.startswith("\xef\xbb\xbf")):
            # remove UTF-8 BOM
            # Note: this is hardly robust Unicode XML handling :)
            line = line[3:]
        if line.startswith("<?xml"):
            while startline < len(lines):
                end_index = lines[startline].find("?>")
                startline += 1
                if end_index != -1: # found end of tag
                    break
            # Note: this does not catch something like this:
            #   <?xml version="2.0"?> <?stylesheet ...
            #   ...?>
            # but that is just crazy.
    # else, advance past a possible shebang line.
    else:
        for comment_delims in comment_delim_sets:
            if (len(comment_delims) == 1 and comment_delims[0] == "#"
                and lines[startline].startswith("#!")):
                startline += 1
        # And advance past an @echo off line
        if lines and lines[startline].startswith("@echo off"):
            startline += 1

    # Advance past an Emacs local variable line.
    comment_delims = None

    # Deal with the possibility that startline might be off the end of the file
    if startline == len(lines):
        print "... single line file or other weirdness"
        results["weird"] += 1
        # XXX e.g. ./layout/reftests/bugs/403505-1-ref.xul
        return
    
    if lines[startline].find("-*-") != -1:
        for comment_delims in comment_delim_sets:
            if lines[startline].find(comment_delims[0]) != -1:
                break
        else:
            # We were hoping to be able to determine which of the set of
            # possible commenting styles was in use by finding the
            # comment start token on the same line as the -*-
            # Emacs-modeline signifier, but could not. This likely means
            # that this file uses a block-style comment but the block
            # doesn't start on the same line. Fallback to the
            # block-style comment delimiter set, if there is one.
            for comment_delims in comment_delim_sets:
                if len(comment_delims) == 3:
                    break
            else:
                comment_delims = comment_delim_sets[0]

        if len(comment_delims) == 1: # line-style comments
            startline += 1
        else: # block-style comments
            in_comment = 0
            while startline < len(lines):
                line = lines[startline]
                linepos = 0
                while linepos < len(line):
                    if not in_comment:
                        i = line.find(comment_delims[0], linepos)
                        if i == -1:
                            break
                        else:
                            in_comment = 1
                            linepos = i+1
                    else:
                        i = line.find(comment_delims[-1], linepos)
                        if i == -1:
                            break
                        else:
                            in_comment = 0
                            linepos = i+1
                startline += 1
                if not in_comment:
                    break
    
    newlicense = _g_newlicense

    if _g_add_incompatible:
        newlicense = newlicense + _g_incompatible
    
    # - add the comment delimiters
    if comment_delims is None:
        comment_delims = comment_delim_sets[0]
        print "comment delims were none: %r" % comment_delims
    t_lines = newlicense.splitlines()
    if len(comment_delims) == 1: # line-style comments
        for i in range(len(t_lines)):
            if t_lines[i]:
                t_lines[i] = comment_delims[0] + ' ' + t_lines[i]
            else: # don't add trailing whitespace
                t_lines[i] = comment_delims[0]
    else: # block-style comments
        if t_lines[0]:
            t_lines[0] = comment_delims[0] + ' ' + t_lines[0]
        else: # don't add trailing whitespace
            t_lines[0] = comment_delims[0]

        # Generate padding spaces equivalent to length of opening delim, -1
        spaces = comment_delims[0]
        spaces = re.sub(".", " ", spaces)
        spaces = spaces[:-1]
        
        for i in range(1, len(t_lines)):
            if t_lines[i]:
                t_lines[i] = spaces + comment_delims[1] + ' ' + t_lines[i]
            else: # don't add trailing whitespace
                t_lines[i] = spaces + comment_delims[1]
                
        # Ick.
        if comment_delims[-1] == "#%]":
#           or comment_delims[-1] == "*/":
            t_lines[-1] += '\n' + spaces + comment_delims[-1]
        else:
            t_lines[-1] += ' ' + comment_delims[-1]

    # Add EOL character
    eol = "\n"
#    if re.search("\r\n", lines[0]):
#        eol = "\r\nYY"
        
    for i in range(len(t_lines)): t_lines[i] += eol
    t_lines[-1] += eol # add a blank line at end of lic block
    newlicense_lines = t_lines
    #pprint.pprint(t_lines)

    # Skip out now if doing a dry-run.
    if _g_dry_run:
        results["added"] += 1
        return

    # Make a backup.
    if backup:
        backup_path = _make_backup_path(original_path)
        print "... backing up to '%s'" % backup_path
        try:
            shutil.copy(original_path, backup_path)
        except EnvironmentError, ex:
            return _relicensing_error(ex, original_path, _errors)

    # Add the license to the file.
    try:
        lines[startline:startline] = newlicense_lines

        fout = open(original_path, "w")
        try:
            fout.write(''.join(lines))
        finally:
            fout.close()
        results["added"] += 1
        print "... done adding license to '%s'" % original_path
    except:
        if backup:
            print "... error adding license, restoring original"
            if os.path.exists(original_path):
                os.remove(original_path)
            os.rename(backup_path, original_path)
        else:
            print "... error adding license, file may be corrupted"
        # fallback to type_ for string exceptions
        type_, value, tb = sys.exc_info()
        return _relicensing_error(value or type_,
                                  original_path, _errors)


def _traverse_dir((file_handler, results), dirname, names):
    """os.path.walk target to traverse the give dir"""
    log.debug("_traverse_dir((file_handler, results), dirname='%s', "
              "names=%s)", dirname, names)
    # Iterate over names backwards because may modify it in-place.
    # Modifying it in-place ensures that removed entries are not
    # traversed by os.path.walk.
    for i in range(len(names)-1, -1, -1):
        path = os.path.join(dirname, names[i])
        if os.path.isdir(path):
            if _should_skip_dir(path):
                del names[i]
                continue
        if os.path.isfile(path):
            if _should_skip_file(path):
                del names[i]
                continue
            if file_handler is not None:
                file_handler(path, results)

def _traverse(paths, file_handler, arg):
    """Traverse the given path(s) and call the given callback for each.
    
        "paths" is either a list of files or directories, or it is an
            input stream with a path on each line.
        "file_handler" is a callable to be called on each file traversed.
            It is called with the following signature:
                file_handler(path, arg)
        "arg" is some object passed to each callback. This is useful for
            recording results.

    This method takes care of skipping files and directories that should
    be skipped according to .cvsignore files and the configured skip
    paths.  This method does not return anything.
    """
    log.debug("_traverse(paths=%s, file_handler=%s, arg=%s)",
              paths, file_handler, arg)

    for path in paths:
        if path[-1] == "\n": path = path[:-1] # chomp if 'paths' is a stream
        if not os.path.exists(path):
            log.warn("'%s' does not exist, skipping", path)
        elif os.path.isfile(path):
            if _should_skip_file(path):
                continue
            if file_handler is not None:
                file_handler(path, arg)
        elif os.path.isdir(path):
            if _should_skip_dir(path):
                continue
            os.path.walk(path, _traverse_dir, (file_handler, arg))
        else:
            raise RelicError("unexpected path type '%s'" % path)



#---- public routines

def relicense(paths,
              backup=0, 
              _errors=None):
    """Relicense the given file(s) (or files in the given dir).
    
        "paths" is either a list of files or directories, or it is an
            input stream with a path on each line.
        "backup" (optional, default false)is a boolean indicating if
            backups should be made
        "_errors" (optional) is a dictionary on which errors are reported
            (keyed by file path) when the force option is in effect.

    This method does not return anything. It will raise RelicError if
    there is a problem. Note that OSError/IOError may also be raised.
    """
    log.debug("relicense(paths=%s, backup=%r)", paths, backup)
    results = {
        "relicensed": 0,
        "no license": 0,
        "empty": 0,
        "good": 0,
        "binary": 0,
    }
    _traverse(paths, _relicense_file,
              (backup,
               results,
               _errors))
    print
    print "--------------------- Summary of Results ------------------------"
    print "Files skipped b/c they are binary:", results["binary"]
    print "Files skipped b/c they already had proper license:", results["good"]
    print "Files skipped b/c they had no license:", results["no license"]
    print "Files skipped b/c they are empty:", results["empty"]
    if _g_dry_run:
        print "Files re-licensed: %d (dry-run)" % results["relicensed"]
    else:
        print "Files re-licensed:", results["relicensed"]
    print "-----------------------------------------------------------------"


def addlicense(paths,
               backup=0, 
               _errors=None):
    """Add a license to those of the given file(s) that do not appear to
    have one.
    
        "paths" is either a list of files or directories, or it is an
            input stream with a path on each line.
        "backup" (optional, default false) is a boolean indicating if
            backups should be made
        "_errors" (optional) is a dictionary on which errors are reported
            (keyed by file path) when the force option is in effect.

    This method does not return anything. It will raise RelicError if
    there is a problem. Note that OSError/IOError may also be raised.
    """
    log.debug("addlicense(paths=%s, backup=%r)", paths, backup)

    results = {
        "added": 0,
        "license": 0,
        "empty": 0,
        "binary": 0,
        "badext": 0,
        "weird": 0,
        "total": 0
    }
    _traverse(paths, _add_license_to_file,
              (backup,
               results,
               _errors))
    print
    print "--------------------- Summary of Results ------------------------"
    print "Files skipped b/c they are binary:", results["binary"]
    print "Files skipped b/c they already had a license:", results["license"]
    print "Files skipped b/c they had an extension we aren't relicensing:", results["badext"]
    print "Files skipped b/c they were empty:", results["empty"]
    print "Files skipped b/c of other weirdness:", results["weird"]
    print "Total files analysed:", results["total"]
    if _g_dry_run:
        print "Files to which a license was added: %d (dry-run)" % results["added"]
    else:
        print "Files to which a license was added: %d" % results["added"]
    print "-----------------------------------------------------------------"


def report(paths, quick=0, _errors=None):
    """Report on the existing licenses in the given file(s).
    
        "paths" is either a list of files or directories, or it is an
            input stream with a path on each line.
        "quick" (optional, default false) is a boolean indicating if only
            basic license checking should be applied.
        "_errors" (optional) is a dictionary on which errors are reported
            (keyed by file path) when the force option is in effect.

    This method does not return anything. It will raise RelicError if
    there is a problem.
    """
    log.debug("report(paths=%s)", paths)
    results = {}
    _traverse(paths,\
          _report_on_file,\
          (results, quick, _errors))


def statistics(paths, extended=0, quick=0, _errors=None):
    """Show a summary table of licenses in files in the given path(s).

        "paths" is either a list of files or directories, or it is an
            input stream with a path on each line.
        "extended" (optional) is a boolean indicating if extended
            statistics should be shown
        "quick" (optional) is a boolean indicating if quick scan mode should
            be enabled.
        "_errors" (optional) is a dictionary on which errors are reported
            (keyed by file path) when the force option is in effect.

    This method does not return anything.
    """
    #XXX Info gathering returns a lot more info now. We might be able to
    #    output more interesting stats.
    log.debug("statistics(paths=%s, extended=%s)",
              paths, extended)
    results = {}
    _traverse(paths, _gather_info_on_file, (results, _errors))

    # Process results and print out some stats.
    stats = {
        # <lic type>: [<number of hits>, [<files>...]]
    }
    for file, info in results.items():
        lic_types = [p for p in info["parts"]
                     if p not in ["block_begin", "block_end"]]
        if not lic_types:
            name = "<none found>"
        elif "unknown" in lic_types:
            name = "<unknown license>"
        # Distinguish between complete mpl/gpl/lgpl (i.e. with the block
        # begin and end tokens) and incomplete mpl/gpl/lgpl. Likewise
        # NPL.
        elif (info["parts"] == ["block_begin", "mpl", "gpl", "lgpl", "block_end"]):
            name = "mpl/gpl/lgpl (standard block)"
        elif (info["parts"] == ["block_begin", "npl", "gpl", "lgpl", "block_end"]):
            name = "npl/gpl/lgpl (standard block)"
        else:
            name = "/".join(lic_types)
        if name not in stats: stats[name] = [0, []]
        stats[name][0] += 1
        stats[name][1].append(file)

    statslist = [(hits, name, files) for name, (hits, files) in stats.items()]
    statslist.sort()    # sort by number of hits
    statslist.reverse() # most common first
    print "Summary of Licenses in Files"
    print "============================"
    print " Number  Percent License"
    print "------- -------- -----------"
          #    115   55.55% npl/gpl
    for hits, name, files in statslist:
        print "%7d %7.2f%% %s"\
              % (hits, (hits*100.0/len(results)), name)
    print "----------------------------"
    print "%7d files processed" % len(results)

    if extended:
        for hits, name, files in statslist:
            print "Files in license category '%s'" % name
            sortedFiles = files[:]
            sortedFiles.sort()
            for file in sortedFiles:
                print "    %s" % file
    print



#---- mainline

def main(argv):
    try:
        opts, args = getopt.getopt(argv[1:], "VvahdqfL:sxrA",
            ["version", "verbose", "all", "help", "debug",
             "dry-run", "force", "license=",
             "statistics", "relicense", "backup", "add",
             "quick", "slow-binary", "incompatible"])
    except getopt.GetoptError, ex:
        log.error(str(ex))
        log.error("Try `%s --help'.", argv[0])
        return 2

    debug = 0
    mode = "report"
    extended = 0
    backup = 0
    quick = 0
    for opt, optarg in opts:
        if opt in ("-h", "--help"):
            sys.stdout.write(__doc__)
            return
        elif opt in ("-V", "--version"):
            ver = '.'.join([str(part) for part in _version_])
            print "relic %s" % ver
            return
        elif opt in ("-v", "--verbose"):
            log.setLevel(logging.INFO)
        elif opt in ("-a", "--all"):
            global _g_check_all
            _g_check_all = 1
        elif opt in ("-d", "--debug"):
            log.setLevel(logging.DEBUG)
            debug = 1
        elif opt in ("--dry-run",):
            global _g_dry_run
            _g_dry_run = 1
        elif opt in ("-f", "--force"):
            global _g_force
            _g_force = 1
        elif opt in ("-s", "--statistics"):
            mode = "statistics"
        elif opt in ("-x",):
            extended = 1
        elif opt in ("-r", "--relicense"):
            mode = "relicense"
        elif opt in ("-A", "--add"):
            mode = "add"
        elif opt == "--backup":
            backup = 1
        elif opt in ("-q", "--quick"):
            quick = 1
        elif opt in ("--slow-binary"):
            global _g_fast_binary
            _g_fast_binary = 0
        elif opt in ("--incompatible"):
            global _g_add_incompatible
            _g_add_incompatible = 1

    try:
        # Prepare the input.
        if not args:
            log.debug("no given files, trying stdin")
            paths = sys.stdin
        else:
            paths = args

        global _g_mode
        _g_mode = mode

        # Invoke the requested action.
        _errors = {}
        if mode == "relicense":
            relicense(paths,
                      backup,
                      _errors=_errors)
        elif mode == "statistics":
            statistics(paths, extended, quick, _errors=_errors)
        elif mode == "report":
            report(paths, quick, _errors=_errors)
        elif mode == "add":
            addlicense(paths,
                       backup,
                       _errors=_errors)
        else:
            raise RelicError("unexpected mode: '%s'" % mode)

        # Report any delayed errors.
        if _errors:
            print
            print "=================== Summary of Errors ==========================="
            print "Files with processing errors:", len(_errors)
            print "================================================================="
            for file, error in _errors.items():
                # First version is just filenames, second adds errors
                print "%s" % (file)
                # print "%s: %s" % (file, error)
                # print
            print "================================================================="
    except RelicError, ex:
        log.error(str(ex) +
                  " (the --force option can be used to skip problematic "
                  "files and continue processing rather than aborting)")
        if debug:
            print
            import traceback
            traceback.print_exception(*sys.exc_info())
        return 1
    except KeyboardInterrupt:
        pass


if __name__ == "__main__":
    sys.exit( main(sys.argv) )
